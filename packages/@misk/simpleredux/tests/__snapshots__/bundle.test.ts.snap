// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Dist bundle action.d.ts is unchanged 1`] = `
"export declare enum SIMPLEREDUX {
    MERGE = \\"SIMPLEREDUX_MERGE\\",
    FAILURE = \\"SIMPLEREDUX_FAILURE\\",
    HTTP_DELETE = \\"SIMPLEREDUX_HTTP_DELETE\\",
    HTTP_GET = \\"SIMPLEREDUX_HTTP_GET\\",
    HTTP_HEAD = \\"SIMPLEREDUX_HTTP_HEAD\\",
    HTTP_PATCH = \\"SIMPLEREDUX_HTTP_PATCH\\",
    HTTP_POST = \\"SIMPLEREDUX_HTTP_POST\\",
    HTTP_PUT = \\"SIMPLEREDUX_HTTP_PUT\\"
}
"
`;

exports[`Dist bundle dispatch.d.ts is unchanged 1`] = `
"import { AxiosResponse, AxiosRequestConfig } from \\"axios\\";
import { SIMPLEREDUX } from \\"./action\\";
import { IDefaultState, IAction } from \\"./utilities\\";
export interface ISimpleCachePayloadTag extends IDefaultState {
    oldToggle?: string | boolean;
    tag: string;
    valueAsString?: string;
    valueAsNumber?: number;
}
export interface ISimpleHttpPayloadTag extends IDefaultState, AxiosResponse {
    requestConfig: AxiosRequestConfig;
    tag: string;
    url: string;
}
export declare type ISimpleReduxPayloadTag = ISimpleCachePayloadTag | ISimpleHttpPayloadTag;
export interface ISimpleReduxPayload {
    [tag: string]: ISimpleReduxPayloadTag;
}
export interface IDispatchSimpleRedux {
    simpleMergeTag: (tag: string, data: any) => IAction<SIMPLEREDUX.MERGE, ISimpleReduxPayload>;
    simpleFailure: (tag: string, error: any) => IAction<SIMPLEREDUX.FAILURE, ISimpleReduxPayload>;
    simpleMerge: (data: any) => IAction<SIMPLEREDUX.MERGE, any>;
    simpleHttpDelete: (tag: string, url: string, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_DELETE, ISimpleReduxPayload>;
    simpleHttpGet: (tag: string, url: string, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_GET, ISimpleReduxPayload>;
    simpleHttpHead: (tag: string, url: string, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_HEAD, ISimpleReduxPayload>;
    simpleHttpPatch: (tag: string, url: string, data: any, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_PATCH, ISimpleReduxPayload>;
    simpleHttpPost: (tag: string, url: string, data: any, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_POST, ISimpleReduxPayload>;
    simpleHttpPut: (tag: string, url: string, data: any, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_PUT, ISimpleReduxPayload>;
    simpleMergeNumber: (tag: string, valueAsNumber: number, valueAsString: string) => IAction<SIMPLEREDUX.MERGE, ISimpleReduxPayload>;
    simpleMergeToggle: (tag: string, oldState: any) => IAction<SIMPLEREDUX.MERGE, ISimpleReduxPayload>;
}
interface IPrivateDispatchSimpleRedux extends IDispatchSimpleRedux {
    simpleFailure: (tag: string, error: any) => IAction<SIMPLEREDUX.FAILURE, ISimpleReduxPayload>;
    simpleMergeTag: (tag: string, data: any) => IAction<SIMPLEREDUX.MERGE, ISimpleReduxPayload>;
    simpleMerge: (data: any) => IAction<SIMPLEREDUX.MERGE, any>;
}
export declare const dispatchSimpleRedux: IPrivateDispatchSimpleRedux;
export interface IDispatchSimpleNetwork {
    simpleNetworkDelete: (tag: string, url: string, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_DELETE, ISimpleReduxPayload>;
    simpleNetworkFailure: (tag: string, url: string, error: any, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.FAILURE, ISimpleReduxPayload>;
    simpleNetworkGet: (tag: string, url: string, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_GET, ISimpleReduxPayload>;
    simpleNetworkHead: (tag: string, url: string, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_HEAD, ISimpleReduxPayload>;
    simpleNetworkPatch: (tag: string, url: string, data: any, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_PATCH, ISimpleReduxPayload>;
    simpleNetworkPost: (tag: string, url: string, data: any, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_POST, ISimpleReduxPayload>;
    simpleNetworkPut: (tag: string, url: string, data: any, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.HTTP_PUT, ISimpleReduxPayload>;
    simpleNetworkSuccess: (tag: string, url: string, response: AxiosResponse, requestConfig?: AxiosRequestConfig) => IAction<SIMPLEREDUX.MERGE, ISimpleReduxPayload>;
}
export declare const dispatchSimpleNetwork: IDispatchSimpleNetwork;
export interface IDispatchSimpleForm {
    simpleFormFailure: (tag: string, error: any) => IAction<SIMPLEREDUX.FAILURE, ISimpleReduxPayload>;
    simpleFormInput: (tag: string, data: any) => IAction<SIMPLEREDUX.MERGE, ISimpleReduxPayload>;
    simpleFormNumber: (tag: string, valueAsNumber: number, valueAsString: string) => IAction<SIMPLEREDUX.MERGE, ISimpleReduxPayload>;
    simpleFormSuccess: (tag: string, data: any) => IAction<SIMPLEREDUX.MERGE, ISimpleReduxPayload>;
    simpleFormToggle: (tag: string, oldState: any) => IAction<SIMPLEREDUX.MERGE, ISimpleReduxPayload>;
}
export declare const dispatchSimpleForm: IDispatchSimpleForm;
export {};
"
`;

exports[`Dist bundle reducer.d.ts is unchanged 1`] = `
"import { IAction, IRootState } from \\"./utilities\\";
import { SIMPLEREDUX } from \\"./action\\";
import { ISimpleReduxPayload } from \\"./dispatch\\";
export declare function SimpleReduxReducer(state: any, action: IAction<SIMPLEREDUX, {}>): any;
export interface ISimpleReduxState extends IRootState {
    [tag: string]: any | ISimpleReduxPayload;
}
export interface ISimpleReduxImmutableState {
    toJS: () => ISimpleReduxState;
}
export declare const SimpleNetworkReducer: typeof SimpleReduxReducer;
export interface ISimpleNetworkState extends IRootState {
    [tag: string]: any | ISimpleReduxPayload;
}
export interface ISimpleNetworkImmutableState {
    toJS: () => ISimpleNetworkState;
}
export declare const SimpleFormReducer: typeof SimpleReduxReducer;
export interface ISimpleFormState extends IRootState {
    [tag: string]: any | ISimpleReduxPayload;
}
export interface ISimpleFormImmutableState {
    toJS: () => ISimpleFormState;
}
"
`;

exports[`Dist bundle saga.d.ts is unchanged 1`] = `
"import { SimpleReduxSaga } from \\"./utilities\\";
export declare function watchSimpleReduxSagas(): SimpleReduxSaga;
export declare const watchSimpleFormSagas: typeof watchSimpleReduxSagas;
export declare const watchSimpleNetworkSagas: typeof watchSimpleReduxSagas;
"
`;

exports[`Dist bundle utilities.d.ts is unchanged 1`] = `
"import { History, Location } from \\"history\\";
import { Map } from \\"immutable\\";
import { match } from \\"react-router\\";
import { ForkEffectDescriptor, SimpleEffect } from \\"redux-saga/effects\\";
import { ParametricSelector } from \\"reselect\\";
export interface CombinatorEffect<T, E> {
    \\"@@redux-saga/IO\\": true;
    combinator: true;
    type: T;
    payload: CombinatorEffectDescriptor<E>;
}
export declare type CombinatorEffectDescriptor<E> = {
    [key: string]: E;
} | E[];
export declare type SimpleReduxSaga = IterableIterator<CombinatorEffect<\\"ALL\\", SimpleEffect<\\"FORK\\", ForkEffectDescriptor>>>;
export interface IRouterProvidedProps {
    history?: History;
    location?: Location;
    match?: match;
}
export interface IDefaultState {
    data: any;
    error: any;
    loading: boolean;
    success: boolean;
}
export interface IRootState {
    simpleTag: string;
}
export interface IDefaultRootState extends IDefaultState, IRootState {
}
export declare const defaultState: any;
export declare const defaultRootState: (simpleTag: string) => any;
export interface IAction<T, P> {
    readonly type: T;
    readonly payload?: P;
}
export declare function createAction<T extends string, P>(type: T, payload: P): IAction<T, P>;
export declare const errorMessage: (error: any) => any;
export declare const selectSubState: <IState extends {
    [key: string]: ISubState;
}, ISubState extends {
    [key: string]: any;
}>(domain: string) => (state: IState) => ISubState;
export declare const selectRawSubState: <IState extends Map<string, any>, ISubState extends {
    [key: string]: any;
}>(domain: string) => (state: IState) => ISubState;
export declare const simpleRootRawSelector: <IState extends Map<string, any>, ISubState>(domain: string, state: IState) => any;
export declare const simpleRootSelector: <IState extends {
    [key: string]: any;
}, ISubState extends {
    toJS: () => IRootState;
}>(domain: string, state: IState) => any;
export declare const enum simpleType {
    array = 0,
    boolean = 1,
    number = 2,
    object = 3,
    string = 4,
    tags = 5
}
export declare const simpleSelect: <IState extends {
    [key: string]: any;
}, ISubState extends {
    [key: string]: any;
}, ISubPayload extends {
    [key: string]: any;
}>(subState: any, tagFilter: string, tagKeysFilter?: string, returnType?: any, subStateSelector?: any) => any;
export declare const simpleSelectorGet: <IState extends {
    [key: string]: any;
}, ISubState extends {
    [key: string]: any;
}, ISubPayload extends {
    [key: string]: any;
}>(subState: any, path: string | string[], defaultValue?: any) => any;
export declare const createSimpleSelectorGet: <ISubState extends {
    [key: string]: any;
}, ISubPayload extends {
    [key: string]: any;
}>(subStateSelector: (state: any) => ISubState, path: string | string[], defaultValue?: any) => ParametricSelector<ISubState, string | string[], any | ISubPayload | ISubPayload[]>;
export declare const simpleSelectorPick: <IState extends {
    [key: string]: any;
}, ISubState extends {
    [key: string]: any;
}, ISubPayload extends {
    [key: string]: any;
}>(subState: any, paths: string | string[]) => any;
export declare const createSimpleSelectorPick: <ISubState extends {
    [key: string]: any;
}, ISubPayload extends {
    [key: string]: any;
}>(subStateSelector: (state: any) => ISubState, paths: string | string[]) => ParametricSelector<ISubState, string | String[], any | ISubPayload | ISubPayload[]>;
export declare const onClickFnCall: (callFn: any, ...args: any) => (event: any) => void;
export declare const onChangeFnCall: (callFn: any, ...args: any) => (event: any) => void;
export declare const onChangeToggleFnCall: (callFn: any, ...args: any) => (event: any) => void;
export declare const onChangeNumberFnCall: (callFn: any, ...args: any) => (valueAsNumber: number, valueAsString: string) => void;
export declare const onChangeTagFnCall: (callFn: any, ...args: any) => (values: string[]) => void;
export declare const booleanToggle: (oldState: string | boolean) => boolean;
export declare const getFirstTag: <T = {
    [key: string]: any;
}, UNIONED_TYPE = {
    [key: string]: any;
}>(payload: {
    [key: string]: UNIONED_TYPE;
}) => T;
export declare const jsonOrString: (json: string) => any;
"
`;
